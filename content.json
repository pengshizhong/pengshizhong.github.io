[{"title":"《redis设计与实现》第三周学习笔记","date":"2017-06-04T11:45:35.000Z","path":"2017/06/04/《redis设计与实现》第三周学习笔记/","text":"1231.redis内部数据存储结构2.redis持久化-RDB原理及文件结构3.redis持久化-AOF原理 redis对象共享 1231.redis内部有一个引用计数的辣鸡回收机制2.redis对于整数字符串是采用对象共享的方式进行存储的，也就是整数新增对象是直接新增引用计数3.因为字符串和其他对象过于复杂目前redis只支持整数的共享 redis键空转时长 1231.redis对象维护着一个lru的值，表示距离上次访问过去了多久2.通过命令 object idletime keyname 可以访问3.当设定LRU相关的回收策略时，如果内存超过maxmemory的配置则会优先删除这些lru高的key redis数据库构成 12341.redis内部分为多个数据库，默认为16个，并且每个数据库之间的数据是不共享的2.一个数据库主要有dict和expires两个键空间，其中dict保存的是数据，expires保存的是过期时间3.redis删除键的策略是惰性删除+定期删除策略的方式进行，惰性删除指的是直到下次操作这个键的时候才来删除，而定期删除则是分多次分不同时间频率来进行循环删除4.从服务器中的过期键永远不会删除，除非主服务器同步了del命令过来 rdb持久化 12341.rdb持久化可以使用save和bgsave，区别是前者会阻塞2.如果开启了AOF持久化，那么优先使用AOF进行恢复3.RDB是一个二进制文件，又多个部分组成，永远不会缺少的是'redis'，版本号，EOF，校验和4.RDB中所有键值对的保存都是长度+值的形式，只是每种类型的键值对最前面的宏定义数字不一样而已 AOF持久化 123451.AOF文件中保存的是一条条的redis命令2.追加的命令并不是直接写到文件，会先写到AOF缓冲区中，之后根据配置会有三种策略同步到文件中3.三种策略分别是每次有新命令都进行写入和同步，隔一秒钟进行同步，由操作系统控制同步，因为即使写入文件的时候操作系统也会先把文件写入到内存缓冲区中，除非强制执行，所以同步和写入的区别是前者写入文件，后者写入缓冲区4.因为AOF是把所有命令保存起来所以文件会越来越大，因此需要一个重写机制，AOF重写其实就是遍历整个数据库，形成回复这个数据库的一条条插入命令，然后原子性的覆盖旧的AOF文件5.关于重写的时候有可能出现的脏数据问题，redis提供了一个重写AOF缓冲区，当开始重写后redis除了要向AOF缓冲区写入命令外，还会向AOF缓冲区继续写入命令，然后在扫描整个数据库之后，最后通过信号的方式通知redis，写入重写AOF缓冲区的内容，完成重写","tags":[]},{"title":"《redis设计与实现》第二周学习笔记","date":"2017-05-21T02:24:22.000Z","path":"2017/05/21/《redis设计与实现》第二周学习笔记/","text":"1231.redis整数集合实现2.redis压缩列表实现3.redis对象及转化（上） 整数集合 集合结构 如果一个集合数量不多，并且只包含整数时，就会使用整数集合结构 123456789typedef struct intset &#123; //编码方式 uint32_t encoding; //长度 uint32_t length; //保存元素的数组，这个数组元素的格式不是int8_t，实际上是又上面的编码方式字段决定的 int8_t contents[];&#125;intset; 集合升级 123456789101112131.为什么要升级因为集合中所有的元素使用的大小都是一样的，因此一旦加入新元素超过了原来单位的长度就需要先升级再插入2.升级的步骤a.为新的数组分配需要的空间b.因为内存位的宽度变了，所以要把数据放到正确的位上c.插入新元素改变length，因为新元素可能是负数所以可能会插在表头3.如果插入元素触发了升级的话那么时间复杂度是O（N）4.一旦升级完成，则永远不会降级5.升级的好处是提高了灵活性，可以节约内存 压缩列表 压缩列表的用途 列表key和哈希key含有少量项并且都是整数或者短字符串时使用压缩列表 压缩列表的结构 12345678910111213//链表结构zlbytes:链表使用的字节长度zltail:链表尾节点zllen:节点数量，小于65535时表示节点数量，等于时需要遍历entry1:列表节点1entry2:列表节点2...zlend:标记列表末端//链表节点结构previous_entry_length:前一个节点的长度 //用于倒序遍历前面的节点encoding:本单位 //记录了content的长度content:内容 连锁更新 因为节点中存在一个字段是保存的是前一个节点的长度，所以如果插入的新节点大小大于254且之前的连续节点都是小于254的话就会触发连锁更新，所有节点的previous_entry_length都要替换连锁更新最坏的情况算法复杂度是O(N*N) redis对象（上） 对象简介 每个redis的键值对都由两个对象组成，key一定是字符串，值则由redis自己判断最适合的数据结构并且会互相转换 123456789//对象结构typedef struct redisObject &#123; //字符串、哈希等等五个对象中的一个 unsigned type; //具体的数据结构类型，通常上面一个对象类型对应至少2种编码类型可以转换 unsigned encoding; //指向底层的数据结构 void *ptr; &#125; 字符串对象的转化 1231.如果一个字符串可以用整数表示，并且可以用long类型，则字符串的编码类型会被设置为int2.如果字符串是一个字符串并且大于32字节，那么会使用SDS，也就是编码对象会被设置为raw3.小于等于32字节的字符串会使用embstr对象，与SDS不同的是，SDS对象会两次申请内存，也就是第一次建立redisObject,第二次建立SDS，然而embstr是一次分配连续空间直接建立redisobject和embstr 链表对象转化 1234当列表同时满足以下两个条件时，使用ziplist（压缩列表）1.所有元素小于64字节2.保存的数量小于512个任何一个不满足都会变成linkedlist 哈希对象转化 1234当哈希表同时满足以下两个条件时，使用ziplist（压缩列表）1.所有元素小于64字节2.保存的数量小于512个任何一个不满足都会变成hashtable 集合对象转化 12345当集合同时满足以下两个条件时，使用intset1.所有元素小于64字节2.保存的数量小于512个任何一个不满足都会变成hashtable如果是集合形式的哈希表，那么key保存的就是集合的值，value则是null","tags":[{"name":"redis设计与实现","slug":"redis设计与实现","permalink":"http://yoursite.com/tags/redis设计与实现/"}]},{"title":"《redis设计与实现》第一周学习笔记","date":"2017-05-14T09:10:16.000Z","path":"2017/05/14/《redis设计与实现》第一周学习笔记/","text":"1231.redis字符串实现2.redis链表实现3.redis字典实现 第二章SDS SDS简介 redis中的一种字符串对象 SDS的结构 123456789struct sdshdr&#123; //当前SDS中字符串的长度 int len; //buf中未使用的字节数量 int free; //字符串值，最后以0填充，0占用的额外一个字节不在len的计算之内 //这样兼容部分C的函数库 char buf[];&#125; 使用SDS而不是C字符串的好处 1231.获取字符串长度可以不再遍历整个数字，复杂度为O(1)2.C字符串不记录字符串长度的大小，所以如果直接操作字符串增加或者减少长度可能会出现内存泄露或者内存溢出的情况3.SDS使用int的数值来判断字符串长度而不是0，并且buf是字节数组，所有API都是二进制安全的 利用free字段实现的减少内存分配次数的技术 121.空间预分配，当修改后的SDS长度大于1m时，除了分配给需要的大小外，还会多分配等量于len字段的长度，如果大于1m，则多分配1m的长度，扩展长度时优先使用buf中的free空间2.惰性空间释放，则是在缩短字符串长度时不释放空间，而是把空间放在buf中修改free的记录 第三章链表 链表结构 1234567891011121314151617181920//链表节点的结构typedef struct listNode &#123; struct listNode *prev; struct listNode *next; void *value;&#125;//list结构typedef struct list &#123; //头结点 listNode *head; //尾节点 listNode *tail; //链表长度 unsigned long len; void *(*dup)(void *ptr); void *(*free)(void *ptr); int (*match)(void *ptr, void *key);&#125; 特点 1因为dup、free、match这三个函数的存在，所以节点中可以存放各种类型的值 第四章字典123456789101112131415161718192021222324252627282930313233343536373839404142//哈希表节点typedef struct dictEntry &#123; void *key; union &#123; void *val; uint64_t u64; int64_t s64; &#125; v; //指向下个哈希表节点，形成链表，哈希冲突的时候有用 struct dictEntry *next;&#125; dictEntry;//哈希表数组typedef struct dictht &#123; //哈希表数组 dictEntry **table; //哈希表大小 unsigned long size; //哈希表大小掩码 //总是等于哈希表大小-1，用来修正哈希值为正确的索引，与运算 unsigned long sizeMask; //哈希表已有节点数量 unsigned long used;&#125;dictht;//字典typedef struct dict &#123; //类型特定函数 dictType *type; //私有数据 void *privdata; //哈希表数组 dictht ht[2]; //rehash索引 //没有进行rehash时为-1 int rehashindex;&#125; 哈希值计算 1231.先使用哈希算法计算哈希值2.计算出的哈希值和sizemask进行位与运算3.计算结果就是插入的索引值 哈希值冲突解决 121.相同的哈希值会使用节点中的next连接起来2.最新的节点永远在最前面 rehash 123456781.什么是rehashrehash是为了让哈希表在数据量过大或者数据量过小的时候仍然能维持较快的查询速度和较高的空间利用率的方法，使用负载因子判断2.什么是负载因子通常是哈希表中的节点数除以哈希表的大小，比如哈希表大小是512，然后现在有1024个节点，那么负载因子就是1024/512=23.rehash的大小哈希表是ht[2]的原因就是其中一个哈希表是用来rehash的如果是扩张，那么ht[1]是第一个大于等于ht[0]使用节点数量*2的2的n次方幂，比如ht[0].used=4，那么ht[1]就是8，因为4*2=8，然后8是第一个大于4的2的n次方如果执行的是收缩操作，那么ht[1]是第一个大于等于ht[0].used的2的n次方 什么是渐进式rehash 123451.为ht[1]分配空间2.设置rehashindex为0开始rehash3.每次在ht[0]增删查改操作时会把ht[0]中索引为rehashindex的键值对移动到rehash到ht[1]上4.rehashindex++5.循环1-4后最后把rehashindex设置为-1 rehash补充 1234561.渐进式rehash的时候修改、删除、查找会在ht[0]和ht[1]上同时进行，就是先在ht[0]上执行，如果没有的话则去ht[1]2.新增的节点则一律放到ht[1]3.当满足以下条件时自动开始rehash（1）服务器没有bgsave和bgrewriteaof时，且负载因子大于等于1（2）服务器bgsave和bgrewriteaof时，且负载因子大于等于5（3）当负载因子小于0.1时执行收缩操作","tags":[{"name":"redis设计与实现","slug":"redis设计与实现","permalink":"http://yoursite.com/tags/redis设计与实现/"}]},{"title":"第七周学习笔记","date":"2017-04-23T12:42:30.000Z","path":"2017/04/23/第七周学习笔记/","text":"下载工具wget123456#1.限制下载速度wget --limit-rate 20k http://www.baidu.com#2.对下载容量进行限制wget -Q 1k http://www.baidu.com#3.镜像网站，很多网站已经屏蔽掉wget了wget -r --mirror url ######lynx格式化打印文本 12#这个工具会把&lt;a href&gt;用文本方式打印出来lynx -dump http://baidu.com ######curl 123456789101112#1.静默下载不显示进度信息curl url --silent#2.设置refercurl --referer 37.com http://baidu.com#3.设置cookiecurl 37.com --cookie \"user=dadjak\"#3.另存cookie文件curl -c cookie.txt http://www.baidu.com#4.查看头部信息curl -I baidu.com#5.curl模拟post请求,wget参数形式一样不过使用的是-post-datacurl -d \"name=name&amp;pass=pash\" tar文本归档123456789101112#1.批量归档,-c表示创建，f表示文件列表，source可以用通配符tar -cf target_name [source]#2.向已经压缩的文件追加文字tar -rvf original_name file#3.列出已经压缩的文件列表tar -tf file#4.查看更详细的文件列表信息tar -tvvf file#5.提取文件内容, x表示提取，-C表示解压缩地址tar -xf file -C target#6.获取文件的指定内容,下面只提取file1和file2tar -xvf file file1 file2","tags":[]},{"title":"第六周学习笔记","date":"2017-04-09T16:00:00.000Z","path":"2017/04/10/第六周学习笔记/","text":"循环迭代字符1234567891011121314151617181920#迭代文件中的每一行#!/bin/bashwhile readline $line; do echo $linedone &lt; test#迭代一行的所有字符,注意，这里的字符串不要加引号#!/bin/basha=1;for i in apple orange change aaaa bbb ccc; do echo $i;done#迭代一个字符串#!/bin/bashword='apple orange change aaaa bbb ccc';for (( i = 0; i &lt; $&#123;#word&#125;; i++ )); do#$&#123;变量名:字符串起点0开始:截取的长度&#125; echo $&#123;word:i:1&#125;done 按列贴合多个文本123456789101112131415161718192021222324252627282930313233343536cat text.txt#输出 cmd_shell.sh debug.sh function.sh get_output.sh printf.sh test_array.sh text.txtcat text2.txt#输出 244 12616 8270 7761 24755 8720 24496 13446 1546 2240#-d指定分隔符，默认是制表符paste -d ' ' text*#输出 cmd_shell.sh 244 debug.sh 12616 function.sh 8270 get_output.sh 7761 printf.sh 24755 test_array.sh 8720 text.txt 24496 13446 1546 2240 awk打印123456789101112131415161718192021222324#awk打印指定行，比如打印第二行到第三行，闭区间，注意是行不是列awk \"NR==2, NR==3\" test.txt#打印匹配正则表达式之间的东西#测试数据➜ /tmp head test.txt2668220415992525978173772726249275646909017432#可以看到最后一行和第一行没了➜ /tmp head test.txt | awk \"/^9/,/0$/\"9925259781737727262492756469090","tags":[{"name":"shell脚本攻略读书笔记","slug":"shell脚本攻略读书笔记","permalink":"http://yoursite.com/tags/shell脚本攻略读书笔记/"}]},{"title":"第五周学习笔记","date":"2017-04-08T16:00:00.000Z","path":"2017/04/09/第五周学习笔记/","text":"学习笔记覆盖内容（因大部分接触过，所以只记录补充的部分） grep awk sed cut 一些常用的grep参数 1234567891011121314151617181920#默认的grep匹配表达式使用的是通配符，如果需要使用普通的正则表达式，要使用如下命令grep -E '表达式内容' filenameegrep '表达式内容' filename#加上color参数可以指定匹配出的颜色grep apple test.txt --color=auto#打印除了匹配行之外的所有行grep -v#打印匹配成功的行数，注意是行数，不是次数grep -c#找出存在匹配性的文件名grep -l apple test.txt test2.txt#找出不存在匹配性的文件名grep -L apple test.txt test2.txt#找出匹配项所在的文件和行数grep -n apple test*#输出：test.txt:4:appletest2.txt:1:apple\\nbannn\\nndsada#递归的寻找某个目录中文件所含内容，可以拿来寻找代码grep 'controller' . -R -n 一些有用的cut指令说明123#cut的一般分割用awk可以更好的掌握，这里记录一些我不知道的用法#1.打印指定序列的长度,下方表示打印出1到5个字符和第7到第10个字符cut -c1-5,7-10 test sed简单说明12345678910111213141516格式： sed 's/匹配的表达式/替换的表达式/' filename#一个简单的示例，把apple替换成orangeecho 'apple banna apple' | sed 's/apple/orange/'#输出如下，可以发现只替换了第一个appleorange banna apple#最后加上g就能替换全部的appleecho 'apple banna apple' | sed 's/apple/orange/g'#移除匹配的行，注意表达式前面的s需要去掉echo 'apple banna apple' | sed '/apple/d'#用&amp;表示匹配到的单词，输出用中括号包裹的apple#注意！！！！sed的大括号是需要转义的echo 'apple banna apple' | sed 's/apple/[&amp;]/g'输出：[apple] banna [apple]#匹配部分的子字符串，比如下面匹配了apple之后把apple替换为括号中的app，第一个括号是\\1，第二个是\\2echo 'apple banna apple' | sed 's/\\(app\\)le/\\1/g'输出：app banna app awk的知识补充1234567891011121314#把外部变量传递到awk内部var1=110var2=220echo | awk '&#123;print var1,var2&#125;' var1=$var1 var2=$var2#输出如下，注意print是使用逗号分隔的，然而打印的时候是空格分隔，赋值语句放在begin &#123;&#125; end的后面110 220#awk的2个内置变量#NR 表示行号#NF 表示字段数,空格分隔cat test | awk '&#123;print NR,NF&#125;'#把外部命令使用awk执行，下面的例子把命令给了cmd这个变量，然后用print执行echo | awk '&#123;\"grep root /etc/passwd\" | getline cmd;print cmd&#125;'","tags":[{"name":"shell脚本攻略读书笔记","slug":"shell脚本攻略读书笔记","permalink":"http://yoursite.com/tags/shell脚本攻略读书笔记/"}]},{"title":"第四周学习笔记","date":"2017-03-27T16:00:00.000Z","path":"2017/03/28/第四周学习笔记/","text":"linux权限知识补充12345678910111213141516#怎么才能删除一个文件，满足以下几个要求1.对目录有可执行权限2.对目录有写权限3.对文件有写权限#什么是粘滞位作用：有这个标志的目录下的文件，只允许所有者和管理员才能删除表示方式：t表示有粘滞位也有可执行权限，T表示有粘滞位但是没有可执行权限#增加粘滞位的方法chmod a+t dir_name#设置sid和gid的方法sid=4000gid=2000只要在原来的777前面加上数字即可因为安全限制，所以uid只有Linux二进制elf文件才能设置#特殊实验文件权限677，则拥有者无法执行此文件 创建不可修改文件12345678910#管理员权限执行以下命令touch /tmp/test.txtsudo chattr +i /tmp/test.txt#这句话报错，管理员也无法写入echo 'test' &gt;&gt; /tmp/test.txt#这里会发现没有内容被写入文件cat /tmp/test.txt#即使管理员权限也无法删除rm /tmp/test.txtchattr -i /tmp/test.txt 快速查看文件差异性123456789101112131415161718192021222324252627282930#文件内容1line 1line 2line 3lalalala#文件内容2line 1line 3line 2papapap#执行此命令diff version1.txt version2.txt#输出如下#+代表在文件1的基础上增加的行，-代表在文件1的基础上增加的行--- version1.txt 2017-04-04 17:51:13.000000000 +0800+++ version2.txt 2017-04-04 17:51:46.000000000 +0800@@ -1,4 +1,4 @@ line 1-line 2 line 3-lalalala+line 2+papapap#保存修改的内容diff -u version1.txt version2.txt &gt;&gt; patch.txt#将文件1恢复成文件2#再执行一次可以撤销patch -p1 version1.txt &lt; patch.txt 切换目录小技巧12345678#pushd把当前目录记录到栈中pushd +num 跳转到指定目录#执行pushd之后会有以下提示，是栈中的内容，从0开始~/Documents ~/Documents/pengshizhong /tmp ~#执行下面命令可以删除栈中的内容，从0开始popd numdirs -v可以查看当前目录序号当前目录总是处于栈顶","tags":[{"name":"shell脚本攻略读书笔记","slug":"shell脚本攻略读书笔记","permalink":"http://yoursite.com/tags/shell脚本攻略读书笔记/"}]},{"title":"第三周学习笔记","date":"2017-03-24T16:00:00.000Z","path":"2017/03/25/第三周学习笔记/","text":"知识点覆盖1.文件处理命令：uniq、sort、comm等命令 2.自动化交互处理命令：expect 3.使用通配符对变量或文件进行解析截取 4.创建测试数据：生成指定大小指定随机内容的测试数据 sort命令的用法123456789101112#1.生成随机数文件用于测试for i in &#123;1..100&#125; do echo $RANDOM &gt;&gt; 123.txt done#2.数字排序，注意默认的排序不是数字大小排序sort -n filename#3.逆序排序sort -r filename#4.指定列进行排序,指定第二列进行排序#生成测试数据for i in &#123;1..100&#125; do echo $i' '$RANDOM&gt;&gt;123.txt;#排序代码sort -nrk 2 uniq命令的用法123456789#注意：这个命令只能对排序后的文件起作用#1.普通用法sort -n 123.txt | uniq#2.统计出现次数sort -n 123.txt | uniq -c#3.找出重复的行sort -n 123.txt | uniq -d#4.截取指定位置的字符串做uniq操作,s表示开始位置w表示截取字数sort -n 123.txt | uniq -s 2 -w 2 截取字符串123456789101112#示例：截取文件名#注意通配符和正则是两码事#下面的示例表示的是截取文件的名字#原理：$&#123;var%.*&#125;这个命令的意思是把变量var从右边开始匹配到的符合%右边的通配符的字符串删除，这个是非贪婪匹配，然而%%是贪婪匹配file='sample.jpg.png';echo $&#123;file%.*&#125;; #输出：sample.jpgecho $&#123;file%%.*&#125; #输出：sample#截取扩展名，原理和上面的一样，只是%变成了#，并且匹配方向为从左到右file='sample.jpg.png';echo $&#123;file#*.&#125;; #输出：sample.jpgecho $&#123;file##*.&#125; #输出：sample 使用通配符匹配所有文件12345#for循环除了数字还可以用通配符for file in *.jpg *.png;do echo $file;done; echo的一些参数指定123456789101112131415161718#若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：#\\a 发出警告声；#\\b 删除前一个字符；#\\c 最后不加上换行符号；#\\f 换行但光标仍旧停留在原来的位置；#\\n 换行且光标移至行首；#\\r 光标移至行首，但不换行；#\\t 插入tab；#\\v 与\\f相同；#\\\\ 插入\\字符；#\\nnn 插入nnn（八进制）所代表的ASCII字符；比如：echo -e \"a\\nbbb\";#输出 #a#bbbecho \"a\\nbbb\"#输出 a\\nbbb expect自动化输入命令1234567891011121314151617#注意文件头不是/bin/bash#!/usr/bin/expect#spawn表示要执行的脚本#expect表示输入提示，支持通配符#send表示要发送的字符串后面要手动加\\n#expect eof表示交互结束#下方为自动登录堡垒机的代码示例#!/usr/bin/expectset user pengshizhongset ip 14.18.204.66set password xxxxset timeout 100spawn ssh $user@$ipexpect \"*assword:*\"send \"$password\\r\"expect eof 文件比较：comm1234567891011121314151617181920212223242526#注意：comm只对排序过的文件起作用#测试数据：for i in &#123;5..15&#125;;do echo $i &gt;&gt; a.txt; done;for i in &#123;1..10&#125;;do echo $i &gt;&gt; b.txt; done;comm a.txt b.txt#输出共三列如下: 1 2 3 4 5 6 7 8 9 101112131415#第一列表示只在第一个输入文件中出现的数据#第二列表示只在第二个输入文件中出现的数据#第三列表示在两个输入中都存在的数据#可以通过加上参数 -123指定删除的输出，注意是删除#列之间的分隔符是制表符，可以用于替换 创建长目录123#如果要创建~/a/b/c/d/e这个目录#直接执行mkdir -p ~/a/b/c/d/e","tags":[{"name":"shell脚本攻略读书笔记","slug":"shell脚本攻略读书笔记","permalink":"http://yoursite.com/tags/shell脚本攻略读书笔记/"}]},{"title":"第二周学习笔记","date":"2017-03-18T16:00:00.000Z","path":"2017/03/19/第二周学习笔记/","text":"知识点覆盖1.shell的函数定义及使用 2.循环结构写法 3.分支结构写法 4.xargs和find使用 函数定义与使用123456789101112131415161718192021#!/bin/bashfunction helloworld() &#123; echo 'hello world!'; #全部参数 echo $@ #第一个参数 echo $1 #当前脚本名称 echo $0 #全部参数 echo $*&#125;helloworld 12 34有几个和普通php脚本不同的地方需要注意：1.函数定义必须在执行脚本之前2.函数定义不需要参数列表3.函数调用不需要括号4.function关键字可有可无5.返回码必须是数字 获取命令的输出123456#!/bin/bashoutput=$(ls|cat -n)echo $outputoutput2=`ls|cat -n`echo $output2 read的几种用法12345678910111213#!/bin/bash#读取2个字符就输入结束read -n 2 varecho $var#不回显的方法输入，比如输入密码read -s var#时限内输入read -t 2 var#定界符,输入input:,则var变成inputread -d ':' var IFS12345678910#!/bin/bashold=$IFSstr=\"name,old,test,oo,das.sdad\"IFS=.for item in $strdoecho $itemdoneIFS=old先设置IFS后可以直接for循环遍历字符串 for循环12345678910111213141516171819202122231.简单for in如上个IFS示例，注意in后面的变量要美元符号2.for循环,注意for循环这一行是不需要美元符号的#!/bin/bashfor((i=0;i&lt;5;i++))do echo $idone3.while循环，主要是条件判断比较坑#!/bin/bashcount=0while [ $count -ne 5 ]do echo $count let count++done4.和wile正好相反#!/bin/bashcount=0until [ $count -eq 5 ]do echo $count let count++done if语句123456789101112131415161718192021222324252627#!/bin/basha=1b=2c=3d=4#-a表示与 -o表示或if [ $a -lt $b -a $c -lt $d ];then echo \"$a is small!\";else echo \"$b is small!\";fi#!/bin/basha=1b=2c=3d=4#注意这个[[]]要写2次#test 可以直接代替中括号比如#if test $a -lt $b &amp;&amp; test $c -lt $d ;if [[ $a -lt $b ]] &amp;&amp; [[ $c -lt $d ]];then echo \"$a is small!\";else echo \"$b is small!\";fi find命令1234567891011121314151617181920211.列出当前目录下所有文件find .2.查找指定文件名使用正则表达式这个比较坑，find的正则表达式不是常用的扩展类型所以最好是用grep，但是注意文件名前面都是带.和/的，需要转义find . | grep -E ^\\./\\*t3.按类型搜索find . -type d4.指定深度find . -type d -maxdepth 3 -mindepth 35.根据修改时间、访问时间、变化时间（权限、所有者）修改find . -type d -atime 7 #7天前访问过的目录，单位是天find . -type d -amin 7 #7分钟前访问过的目录，单位是天6.基于文件大小，可用单位：b（512字节），c（字节），w（字），k，m，gfind . -type d -size +2k #+表示大于，-表示小于7.根据权限查找find . -perm 7778.根据所有者查找find . -user www9.对每个找到的文件使用exec后面的命令，注意最后要用 空格+\\;结尾find . -type d -maxdepth 3 -mindepth 3 -user www -exec cat &#123;&#125;'jkhkj' \\; xargs用法123456781.多行变一行cat test.txt | xargs2.一行变多行echo 'djhsa djkahsdkaj dsahdjka dasjdka' | xargs -n 23.指定分隔符echo 'djhsaXdjkahsdkajXdsahdjkaXdasjdka' | xargs -d X4.设置参数模板echo '123 123 123' | xargs -I &#123;&#125; -n 1 echo &#123;&#125;'dsa'; tr解释字符串12341.小写转大写cat /etc/passwd | tr 'a-z' 'A-Z'2.删除指定字符cat /etc/passwd | tr -d 'a-z'","tags":[{"name":"shell脚本攻略读书笔记","slug":"shell脚本攻略读书笔记","permalink":"http://yoursite.com/tags/shell脚本攻略读书笔记/"}]},{"title":"第一周学习笔记","date":"2017-03-11T16:00:00.000Z","path":"2017/03/12/第一周学习笔记/","text":"知识点覆盖1.字符串常用操作 2.shell数学运算 3.文件描述符与重定向运用 4.简单数组和关联数组运用 5.shell脚本调试方法 格式化输出1234567891011121314#注意：如果格式化使用了d那么后面一定要是整形数字，不然会报错#d s f 这些和C相同，分别代表数据类型#-5 -10 -4则代表对其，-表示左对齐#!/bin/bashprintf \"%-5s %-10s %-4s\\n\" No Name Markprintf \"%-5d %-10s %-4.2f\\n\" 1 pengshzihong 89.222printf \"%-5d %-10s %-4.3f\\n\" 1 pengshzihong 82.123printf \"%-5d %-10s %-4.0f\\n\" 1 pengshzihong 82.12以上代码输出：No Name Mark1 pengshzihong 89.221 pengshzihong 82.1231 pengshzihong 82 获取进程ID123pgrep 进程名称命令： pgrep php输出： 414 获取字符串长度的方法 1234var=23618236187length=$&#123;#var&#125;echo $length输出：11 获取用户UID 123#UID是一个环境变量，管理员是0uid=$UIDecho $uid 数学计算(整形运算)123456789101112131415161718192021#注意，let的计算是不用加美元符号的，可以像其他编程语言一样计算a=1b=2let result=a+becho $resultlet result++echo $resultlet result+8echo $resultlet result-3echo $result#其他方法：(()) 这种一定要在变量前面加美元符号,括号前面也要result=$(($a+$b))echo $result#其他方法：[] 数组符号，这个和let一样result=$[a+b];echo $result#exprresult=$(expr $a + $b);echo $result; 高级运算12345678910111213141516#使用管道输出表达式到bcecho \"89.2 * 2882 \"| bc#传递scale参数可以设置小数点后面的精确度echo \"scale=1;3/8\" | bc#进制转换#十进制转化2进制test=10echo \"obase=2;$test\" | bc#二进制转换为10进制echo \"obase=10;ibase=2;1010\" | bc#计算平方和平方根echo \"sqrt(100)\"| bcecho \"2^3\"| bc 几种重定向文件描述符写法解析 1234567891011121314#把正确错误信息都写入/tmp/testls + &amp;&gt; /tmp/test#把错误信息写入testls + 2&gt;/tmp/test#tee把标准输入写入文件同时作为标准输出传递给下一个命令#注意tee只会读取标准输入的信息，所以第二个命令执行时没有数据的ls | tee /tmp/test | wc -lls +| tee /tmp/test | wc -l#把EOF的多行文本做为输入写入文件cat &lt;&lt; EOF &gt;&gt; /tmp/testtesteof 自定义文件描述符1234567891011121314#注意&amp;号一定要有#而且只读文件描述符只能使用一次！exec 3 &lt; /tmp/testcat &lt;&amp;3;#截断模式的话，会一直从当前的位置向后覆盖exec 5&gt;/tmp/testecho 'test' &gt;&amp;5#直接追加exec 6&gt;&gt;/tmp/testecho 'test' &gt;&amp;6注意：如果同时存在截断和追加的文件描述符，截断模式写入的数据会从截断的位置开始一行一行的覆盖掉后面其他描述符加入的数据 简单数组定义1234567891011#数组定义方法一： array=(1 2 3 4 5 6)方法二： 注意，直接赋值的方法索引必须是数字！！！array[1]=4array=[2]=5;#打印全部数组echo $array[*] 或者是 echo $array[@]#打印数组长度echo $&#123;#array[*]&#125; 或者echo $&#123;#array[*]&#125; 关联数组123456789#关联数组声明首先是需要显式的定义declare -A guanlian#给关联数组赋值可以像普通数组那样单个赋值，批量赋值如下guanlian=([apple]='5' [orange]='6') #mac下实验暂时不成功#单个赋值不需要双引号guanlian[key]=value#其他获取长度和值和普通一样#获取所有键的方法echo $&#123;!guanlian[*]&#125; #mac下暂不成功 别名设置1234建立别名：alias new_cmd='ls -l'解除别名：unalias new_cmd重复创建新的别名会取代旧的为了防止使用别名中使用了已经定义的别名可以在cmd中加上\\来强行运行原来的命令 控制终端显示输入12stty -echo;read 让输入不在终端显示stty echo; read 输入会在终端显示 调试脚本 123456#启动方式：bash -x script_name在set -x和set +x 直接的东西会处于调试模式，详情见debug.sh另外直接把脚本的!#/bin/bash改为 !#/bin/bash -xv也会直接进入调试模式，详情见debug.sh","tags":[{"name":"shell脚本攻略读书笔记","slug":"shell脚本攻略读书笔记","permalink":"http://yoursite.com/tags/shell脚本攻略读书笔记/"}]}]